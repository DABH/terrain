[
  {
    "Select":
    { 
      "Snippet": "Get data", 
      "Summary": "The Select statement returns a result set of records from one or more tables.",
      "Type": "prefix operator",
      "Syntax": "SELECT field name(s)",
      "Text": 
      [ 
        [
          {
            "id": "c-2735991550",
            "parentId": "CI2XI",
            "properties": [{
              "id": "0.9",
              "property": "user.name"
            }],
            "type": "select"
          },
          "from 'users' as user\nselect user.name"
        ],
        "The TQL Select statement returns a result set of records from one or more tables. A Select statement retrieves zero or more rows from one or more database tables or database views. In most applications, Select is the most commonly used data manipulation language (DML) command. As TQL is a declarative programming language, Select queries specify a result set, but do not specify how to calculate it. The database translates the query into a query plan which may vary between executions, database versions and database software. This functionality is called the query optimizer as it is responsible for finding the best possible execution plan for the query, within applicable constraints.",
        "Select all the product id's purchased by user 1234:",
        [
          {
            "id": "c-2735991550",
            "parentId": "CI2XI",
            "properties": [{
              "id": "0.9",
              "property": "user.name"
            }],
            "type": "select"
          },
          "from 'products' as product \n\tfilter product.id in \n\t\t from 'orders' as order \n\t\t\tfilter order.user == 1234 \n\t\t\tselect order.product \n\tselect product.id"
        ]
      ]
    },
    "Take":
    { 
      "Snippet": "Returns n results", 
      "Summary": "Returns a query expression representing the first n results from the expression on the left hand side.  The number of results n is the evaluation of the right hand side.", 
      "Type": "binary infix operator",
      "Syntax": "query expression TAKE expression",
      "Text": 
      [ 
        [
          {
            "id": "c-4",
            "parentId": "c-2",
            "type": "take",
            "value": "10"
          },
          "take 10"
        ],
        "Take is a binary infix operator, meaning it sits between two expressions. Take returns a query expression that is the first n results of the query expression on its left hand side.  The number of results n to be returned is determined from the right hand side. In order to get a specific set of results, the data can be sorted based on some parameter first and then the top n results selected via Take. For example, if you wanted the 10 oldest people in a group, you would sort the people based on descending age and then use 'Take 10'.",
        "This example takes the first 10 results (the names of users) from the table 'users.'",
        [
        {
          "cards": [
            {
              "id": "c-3",
              "parentId": "c-2",
              "properties": [
                {
                  "id": "0.6",
                  "property": "user.name"
                }
              ],
              "faded": true,
              "type": "select"
            },
            {
              "id": "c-4",
              "parentId": "c-2",
              "type": "take",
              "value": "3",
              "highlighted": true
            }
          ],
          "group": "users",
          "id": "c-2",
          "iterator": "user",
          "joins": [],
          "parentId": "8R",
          "type": "from",
          "faded": true
        },
          "from 'users' as user\nselect user.name\ntake 3\n\n//John Smith\n//Sarah Johnson\n//Ann Walter"
        ]
      ]
    },
    "From":
    { 
      "Snippet": "Elements from specified source", 
      "Summary": "Returns a query expression representing all elements in the given source. The elements are defined as using the expression 'as definition' and can be refered to throughout the query by this definition.", 
      "Syntax": "FROM source AS definition",
      "Text": 
      [ 
        "The From clause is the source be operated upon in a Data Manipulation Language (DML) statement. From clauses are very common, and will provide the rowset to be exposed through a Select statement, the source of values in an Update statement, and the target rows to be deleted in a Delete statement.",
        [
          {
            "cards": [],
            "id": "c-2735991550",
            "parentId": "CI2XI",
            "group": "users",
            "iterator": "user",
            "joins": [],
            "type": "from"
          },
          "from 'users' as user"
        ],
        "In this example, users are selected from the table named 'users' and sorted or ordered based on their names",
        [
          {
            "cards": [{
              "id": "c-4",
              "parentId": "c-2735991550",
              "sorts": [{
                "direction": 1,
                "id": "s0.1",
                "property": "name"
              }],
              "type": "sort",
              "faded": true
            }],
            "id": "c-2735991550",
            "parentId": "CI2XI",
            "group": "users",
            "iterator": "user",
            "joins": [],
            "type": "from",
            "highlighted": true
          },
          "from 'users' as user\nORDER BY user.name desc"
        ]

      ]
    },
    "Skip":
    { 
      "Snippet": "Removes first n elements", 
      "Summary": "Returns a query expression representing the left-hand query expression, with the first n elements removed, where n is the result of evaluating the right-hand expression.", 
      "Type": "binary infix operator",
      "Syntax": "query expression SKIP expression (n)",
      "Text": 
      [ 
        [
          {
             "id": "c-2735991550",
             "parentId": "CI2XI",
             "value": "10",
             "type": "skip"
          },
          "skip 10"
        ],
        "The Skip operator skips the first n elements of the query expression on its left hand side.  The number of elements, n, to skip is the evaluating of the right-hand side. Using Skip skips the first n elements and then takes all of the remaining rows. ",
        "This example gets the 26th-50th visible products in the 'cool stuff' category, sorted by creation date",
        [
          {
            "cards": [
              {
                "id": "c-2",
                "parentId": "c-1",
                "sorts": [
                  { 
                    "direction": 1,
                    "id": "s0.1",
                    "property": "product.createdOn"
                  } 
                ],
                "type": "sort",
                "faded": true
              },
              {
                "id": "c-3",
                "parentId": "c-1",
                "type": "skip",
                "value": "25",
                "highlighted": true
              },
              {
                "id": "c-4",
                "parentId": "c-1",
                "type": "take",
                "value": "25",
                "faded": true
              }
            ],
            "filters": [
              {
                "combinator": 0,
                "condition": {
                  "first": "p.visible",
                  "operator": 0,
                  "second": "true"
                },
                "id": "co0.5"
              },
              {
                "combinator": 0,
                "condition": {
                  "first": "p.category",
                  "operator": 0,
                  "second": "'cool stuff'"
                },
                "id": "111"
              }
            ],
            "group": "products",
            "iterator": "p",
            "id": "c-1",
            "joins": [],
            "parentId": "c-0",
            "properties": [{
              "id": "0.8",
              "property": "*"
            }],
            "type": "sfw",
            "faded": true
          },
          "SELECT *\nFROM 'products' as p\nWHERE p.visible == true \n&& p.group == 'cool stuff'\nORDER BY p.createdOn desc\nskip 25\ntake 25\n;"
        ]
      ]
    }, 
    "Order By":
    { 
      "Snippet": "Sorts the elements", 
      "Summary": "Returns a query expression representing the result of sorting the left-hand expression in ascending order of the value returned by the right-hand expression.", 
      "Type": "binary infix operator",
      "Syntax": "query expression ORDER BY expression",
      "Text": 
      [ 
        [
          {
             "id": "c-2735991550",
             "parentId": "CI2XI",
             "value": "10",
             "sorts": [{
                "id": "0.9",
                "direction": 1,
                "property": "user.name"
              }],
             "type": "sort"
          },
          "ORDER BY user.name descending"
        ],
        "An ORDER BY clause in SQL specifies that a SQL SELECT statement returns a result set with the rows being sorted by the values of one or more columns. The sort criteria do not have to be included in the result set. The sort criteria can be expressions, including column names, user-defined functions, arithmetic operations, or CASE expressions. The expressions are evaluated and the results are used for the sorting, i.e., the values stored in the column or the results of the function call. ORDER BY is the only way to sort the rows in the result set. Without this clause, the relational database system may return the rows in any order. If an ordering is required, the ORDER BY must be provided in the SELECT statement sent by the application. Although some database systems allow the specification of an ORDER BY clause in subselects or view definitions, the presence there has no effect. A view is a logical relational table, and the relational model mandates that a table is a set of rows, implying no sort order whatsoever. The only exception are constructs like ORDER BY ORDER OF ... (not standardized in SQL:2003) which allow the propagation of sort criteria through nested subselects.",
        "This example sorts the users from'users' in descending order by their name.",
        [
        {
          "cards": [
            {
              "id": "c-4",
              "parentId": "c-2",
              "sorts": [{
                "id": "0.9",
                "direction": 1,
                "property": "user.name"
              }],
              "type": "sort",
              "highlighted": true
            }
          ],
          "group": "users",
          "id": "c-2",
          "iterator": "user",
          "joins": [],
          "parentId": "8R",
          "type": "from",
          "faded": true
        },
           "from 'users' as user \n\t ORDER BY user.name desc"
        ]
      ]
    }, 
    "Let":
    { 
      "Snippet": "Defines variable", 
      "Summary": "Returns a query expression representing the result of evaluating each the right hand statement for each element.", 
      "Type": "binary infix operator",
      "Syntax": "query expression LET statement",
      "Text": 
      [ 
        [
          {
            "id": "c-3",
              "parentId": "c-2",
              "field":"product.score",
              "expression": "product.age * product.conversionRatio",
              "type": "let"
          },
          "let product.score = \nproduct.age * product.conversionRatio "
        ],
        "The SQL SELECT statement returns a result set of records from one or more tables. A SELECT statement retrieves zero or more rows from one or more database tables or database views. In most applications, SELECT is the most commonly used data manipulation language (DML) command. As SQL is a declarative programming language, SELECT queries specify a result set, but do not specify how to calculate it. The database translates the query into a query plan which may vary between executions, database versions and database software. This functionality is called the query optimizer as it is responsible for finding the best possible execution plan for the query, within applicable constraints. The SQL From clause is the source of a rowset to be operated upon in a Data Manipulation Language (DML) statement. From clauses are very common, and will provide the rowset to be exposed through a Select statement, the source of values in an Update statement, and the target rows to be deleted in a Delete statement.A WHERE clause in SQL specifies that a SQL Data Manipulation Language (DML) statement should only affect rows that meet specified criteria. The criteria are expressed in the form of predicates. WHERE clauses are not mandatory clauses of SQL DML statements, but can be used to limit the number of rows affected by a SQL DML statement or returned by a query. In brief SQL WHERE clause is used to extract only those results from a SQL statement, such as: SELECT, INSERT, UPDATE, or DELETE statement.",
        "This example get the id's of the top 10 products, sorted by .9 * conversionRatio + .1 * promotionBoost, using a 1/10 prior on conversion ratio.",
        [
        {
          "cards": [
            {
              "id": "c-3",
              "parentId": "c-2",
              "field":"product.conversionRatio",
              "expression": "(product.purchases + 1) / (product.views + 10)",
              "type": "let",
              "highlighted": true
            },
            {
              "id": "c-4",
              "parentId": "c-2",
              "field":"product.score",
              "expression": ".9 * product.conversionRatio  + .1 * product.promotionBoost",
              "type": "let",
              "highlighted": true
            },
            {
              "id": "c-5",
              "parentId": "c-2",
              "sorts": [{
                "id": "0.9",
                "direction": 1,
                "property": "product.createdOn"
              }],
              "type": "sort",
              "faded": true
            },
            {
              "id": "c-6",
              "parentId": "c-2",
              "type": "take",
              "value": "10",
              "faded": true
            },
            {
              "id": "c-7",
              "parentId": "c-2",
              "properties": [{
                "id": "0.9",
                "property": "product.id"
              }],
              "type": "select",
              "faded": true
            }
          ],
          "group": "products",
          "id": "c-2",
          "iterator": "product",
          "joins": [],
          "parentId": "8R",
          "type": "from",
          "faded": true
        },
           "from 'products' as product \n\tlet product.concersionRatio =\n(product.purchases + 1) / (product.views + 10) \n\tlet product.score =\n\t\t.9 * product.conversionRatio \n\t\t+ .1 * product.promotionBoost \n\tORDER BY product.createdOn desc \n\ttake 10 \n\tselect product.id"
        ]
      ]
    },
    "Count":
    { 
      "Snippet": "Number of elements", 
      "Summary": "Returns an the number of elements in the right hand expression", 
      "Type": " binary prefix operator",
      "Syntax": "COUNT expression",
      "Text": 
      [ 
        "The TQL Count function returns the number of rows in a table satisfying the criteria specified in the Where clause. It sets on the number of rows or non NULL column values. Count returns 0 if there were no matching rows.",
        "This example returns the number of users with the name John",
        [
          {
            "cards": [ {
              "id": "c-2735991550",
              "parentId": "CI2XI",
              "cards": [],
              "filters": [{
                "combinator": 0,
                "condition": {
                  "first": "user.name",
                  "operator": 0,
                  "second": "John"
                },
              "id": "co0.766099087301130"
              }],
              "group": "users",
              "iterator": "user",
              "joins": [],
              "properties": [{
                "property": "*",
                "id": "0.6"
              }],
              "type": "sfw"
            }],
              "id": "c-2735991550",
              "parentId": "CI2XI",
              "type": "count"
            },
            "count (\n\tselect *\n\tfrom 'users' as user\n\twhere user.name == John\n)"
        ]
      ]
    },
     "Min":
    { 
      "Snippet": "Returns minimum element", 
      "Summary": "Returns an the minimum of all elements in the right hand side", 
      "Type": "binary prefix operator",
      "Syntax": "MIN expression",
      "Text": 
      [ 
        "The syntax for the MIN function in SQL is:",
        [
          {
             "cards": [ {
              "id": "c-2735991550",
              "parentId": "CI2XI",
              "cards": [],
              "filters": [{
                "combinator": 0,
                "condition": {
                  "first": "user.name",
                  "operator": 0,
                  "second": "John"
                },
              "id": "co0.766099087301130"
              }],
              "group": "users",
              "iterator": "user",
              "joins": [],
              "properties": [{
                "property": "*",
                "id": "0.6"
              }],
              "type": "sfw"
            }],
              "id": "c-2735991550",
              "parentId": "CI2XI",
              "type": "min"
          },
          "min();"
        ]
      ]
    },
     "Max":
    { 
      "Snippet": "Returns maximum element", 
      "Summary": "Returns an the maximum of all elements in the right hand side", 
      "Type": "binary prefix operator",
      "Syntax": "MAX expression",
      "Text": 
      [ 
        "The syntax for the MIN function in SQL is:",
        [
          {
             "cards": [ {
              "id": "c-2735991550",
              "parentId": "CI2XI",
              "cards": [],
              "filters": [{
                "combinator": 0,
                "condition": {
                  "first": "user.name",
                  "operator": 0,
                  "second": "John"
                },
              "id": "co0.766099087301130"
              }],
              "group": "users",
              "iterator": "user",
              "joins": [],
              "properties": [{
                "property": "*",
                "id": "0.6"
              }],
              "type": "sfw"
            }],
              "id": "c-2735991550",
              "parentId": "CI2XI",
              "type": "max"
          },
          "max();"
        ]
      ]
    },
    "Sum":
    { 
      "Snippet": "Returns the sum", 
      "Summary": "Returns an the sum of all elements in the right hand side.", 
      "Type": "binary prefix operator",
      "Syntax": "SUM expression",
      "Text": 
      [ 
        "The sum card does not have a description yet."
      ]
    },
    "Avg":
    { 
      "Snippet": "Returns the average", 
      "Summary": "Returns the average of all elements in the right hand side.", 
      "Type": "binary prefix operator",
      "Syntax": "AVG expression",
      "Text": 
      [ 
        "The avg card does not have a description yet."
      ]
    },
    "Select From Where":
    {
      "Snippet": "Retrieves rows from the database", 
      "Summary": "Retrieves rows from the database if they meet the condition", 
      "Type": "none",
      "Syntax": "SELECT FROM source WHERE search condition",
      "Text": 
      [ 
        "The Select From Where card does not have a description yet."
      ]
    },
     "Compare":
    {
      "Snippet": "Compare two terms", 
      "Summary": "The Compare card can be used to compare two values/terms/expressions to one another.", 
      "Type": "binary infix operator",
      "Syntax": "expression COMPARATOR expression",
      "Text": 
      [ 
        "The TQL Compare card is used to add comparisons into the queries.  These comparisons test for equality (==), inequality (!=), less than (<), greater than (>), and ‘in’ and ‘not in’.  ‘In’ and ‘not in’ are used to test whether one query expression is in another; for example, to check if a given user is in a table of users."
      ]
    },
     "Score":
    {
      "Snippet": "Used to rank result", 
      "Summary": "Score is used to rank and order results from a query. The score is based on a weighted sum of attributes of the elements.", 
      "Type": "binary prefix operator",
      "Syntax": "linearScore[([weight1, attribute1], [weight2, attribute2]...)]",
      "Text": 
      [ 
        "The Score card does not have a description yet."
      ]
    },
     "If":
    {
      "Snippet": "Determines if code will be executed", 
      "Summary": "Will execute a block of code if specified condition is true", 
      "Type": "None",
      "Syntax": "IF (condition)",
      "Text": 
      [ 
        "The if statement specifies a block of code to be executed if a condition is true. The else statement specifies a block of code to be executed if the condition is false. The else if statement specifies a new condition if the first condition is false. The condition is an expression that evaluates to true or false. "
      ]
    },
     "Exists":
    {
      "Snippet": "Returns if exists", 
      "Summary": "Tests whether the inner query returns any row.", 
      "Type": "None",
      "Syntax": "WHERE EXISTS (subquery)",
      "Text": 
      [ 
        "Exists tests whether the inner query returns any row. If it does, then the outer query proceeds. If not, the outer query does not execute, and the entire SQL statement returns nothing.",
        "The subquery is a Select statement. If the subquery returns at least one record in its result set, the Exists clause will evaluate to true and the Exists condition will be met. If the subquery does not return any records, the Exists clause will evaluate to false and the Exists condition will not be met."
      ]
    },
     "Var":
    {
      "Snippet": "Declares a variable", 
      "Summary": "Declares a variable", 
      "Type": "binary infix operator",
      "Syntax": "VAR name",
      "Text": 
      [ 
        "The Var card does not have a description yet."
      ]
    },
     "Transform":
    {
      "Snippet": "None", 
      "Summary": "None", 
      "Type": "None",
      "Syntax": "None",
      "Text": 
      [ 
        "The Transform card does not have a description yet."
      ]
    },
     "()":
    {
      "Snippet": "None", 
      "Summary": "None", 
      "Type": "None",
      "Syntax": "None",
      "Text": 
      [ 
        "The () card does not have a description yet."
      ]
    }
  },
  {
    "Expression":
    {  
      "Summary": "A TQL expression is any valid combination of expressions and operators that returns a single value.",
      "Text": 
      [ 
        "Examples: ",
        "2",
        "'name'",
        "2+2",
        "3+2*4+func('group')"
      ]
    },
    "Statement":
    {
      "Summary": "All operations performed using TQL statements",
      "Text": 
      [ 
        "A Tql statement is one of: ",
        "- A code block, enclose in curly braces.",
        "- An expression that does not begin with a curly brace.",
        "- A bare semicolon, which is treated as whitespace."
      ]
    },
    "Binary Infix":
    {
      "Summary": "Sits between two expressions",
      "Text": 
      [ 
        "Infix notation is the notation commonly used in arithmetical and logical formulae and statements. It is characterized by the placement of operators between operands – 'infixed operators' – such as the plus sign in '2 + 2'.",
        "In infix notation, unlike in prefix or postfix notations, parentheses surrounding groups of operands and operators are necessary to indicate the intended order in which operations are to be performed. In the absence of parentheses, certain precedence rules determine the order of operations."
      ]
    },
    "Binary Prefix":
    {
      "Summary": "Precedes it's target",
      "Text": 
      [ 
        "You implement a prefix or postfix unary operator by writing the prefix modifier before the func keyword when declaring the operator function."
      ]
    }
  }
]



