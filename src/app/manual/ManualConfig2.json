[
  {
   "Select From":
    { 
      "summary": "Retrieves rows from the database if they meet the condition", 
      "notation": "none",
      "syntax": "SELECT field(s) FROM source WHERE condition(s)",
      "text": 
      [ 
        "The TQL Select statement returns a result set of records from one or more tables. A Select statement retrieves zero or more rows from one or more database tables or database views. In most applications, Select is the most commonly used data manipulation language (DML) command. As TQL is a declarative programming language, Select queries specify a result set, but do not specify how to calculate it. The database translates the query into a query plan which may vary between executions, database versions and database software. This functionality is called the query optimizer as it is responsible for finding the best possible execution plan for the query, within applicable constraints.",
         [
          {
            "cards": [],
            "fields": [
              { 
                "type": "field",
                "field": "user.name",
                "id": "b"
              }
            ],
            "filters": [
              { 
                "combinator": 0,
                "first": "user.name",
                "operator": 0,
                "second": "John",
                "type": "filterBlock",
                "id": "c"
              }
            ],
            "tables": [
            {
              "iterator": "user",
              "table": "users",
              "type": "table",
              "id": "d"
            }
            ],
            "type": "sfw",
            "id": "e"
          },
          "SELECT user.name\nFROM 'users' as user\nWHERE user.name == John;"
        ],
        "This example select all the product ids purchased by user 1234:",
         [
          {
            "cards": [],
            "fields": [
              { 
                "type": "field",
                "field": "product.id",
                "id": "b"
              }
            ],
            "filters": [
              { 
                "combinator": 0,
                "first": "product.id",
                "operator": 6,
                "second": {
                  "cards": [{
                    "cards": [],
                    "fields": [
                      { 
                        "type": "field",
                        "field": "order.product",
                        "id": "bb"
                      }
                    ],
                    "filters": [
                      { 
                        "combinator": 0,
                        "first": "order.user",
                        "operator": 0,
                        "second": "1234",
                        "type": "filterBlock",
                        "id": "cc"
                      }
                    ],
                    "tables": [
                    {
                      "iterator": "order",
                      "table": "'orders'",
                      "type": "table",
                      "id": "dd"
                    }
                    ],
                    "type": "sfw",
                    "id": "ee"
                  }],
                  "id": "g",
                  "type": "parentheses"
                },
                "type": "filterBlock",
                "id": "c"
              }
            ],
            "tables": [
            {
              "iterator": "product",
              "table": "'products'",
              "type": "table",
              "id": "d"
            }
            ],
            "type": "sfw",
            "id": "e"
          },
          "SELECT product.id\nFROM 'products' as product\nWHERE product.id in (\n\tSELECT order.product\n\tFROM 'orders' as order\n\tWHERE order.user = 1234\n);"
        ]
      ]
    },
    "Take Limit":
    { 
      "snippet": "Returns n results", 
      "summary": "Returns a query expression representing the first n results from the expression on the left hand side.  The number of results n is the evaluation of the right hand side.", 
      "notation": "binary infix operator",
      "syntax": "query expression TAKE expression",
      "text": 
      [ 
        [
          {
            "type": "take",
            "value": "10",
            "id": "a"
          },
          "take 10"
        ],
        "Take is a binary infix operator, meaning it sits between two expressions. Take returns a query expression that is the first n results of the query expression on its left hand side.  The number of results n to be returned is determined from the right hand side. In order to get a specific set of results, the data can be sorted based on some parameter first and then the top n results selected via Take. For example, if you wanted the 10 oldest people in a group, you would sort the people based on descending age and then use 'Take 10'.",
        "This example takes the first 10 results (the names of users) from the table 'users.'",
        [
          {
            "cards": [
              {
                "type": "take",
                "value": 10,
                "id": "a"
              }
            ],
            "fields": [
              { 
                "type": "field",
                "field": "user.name",
                "id": "b"
              }
            ],
            "filters": [
              { 
                "combinator": 0,
                "first": "user.name",
                "operator": 0,
                "second": "John",
                "type": "filterBlock",
                "id": "c"
              }
            ],
            "tables": [
            {
              "iterator": "user",
              "table": "users",
              "type": "table",
              "id": "d"
            }
            ],
            "type": "sfw",
            "id": "e"
          },
          "SELECT user.name\nFROM 'users' as user\nWHERE user.name == John\ntake 10;"
        ]
      ]
    },
    "Sort":
    { 
      "snippet": "none", 
      "summary": "Returns a query expression representing the result of filtering the left-hand expression by evaluating the right-hand expression for each element in the query  expression. Elements that cause the expression to be false are filtered out.",
      "notation": "binary infix operator",
      "syntax": "query expression sort expression",
      "text": 
      [ 
        "from 'users' as user sort user.name",
        [
          {
            "type": "sort",
            "id": "3",
            "sorts": [
              {
                "direction": "1",
                "property": "user.id",
                "id": "b"
              }
            ]
          },
          "ORDER BY user.id desc"
        ]
      ]
    },
    "Filter":
    { 
      "snippet": "none", 
      "summary": "Returns a query expression representing the result of filtering the left-hand expression by evaluating the right-hand expression for each element in the query  expression. Elements that cause the expression to be false are filtered out.",
      "notation": "binary infix operator",
      "syntax": "query expression filter expression",
      "text": 
      [ 
        "none"
      ]
    },
    "Let":
    { 
      "snippet": "Defines variable", 
      "summary": "Returns a query expression representing the result of evaluating each the right hand statement for each element.", 
      "type": "binary infix operator",
      "syntax": "query expression LET statement",
      "text": 
      [ 
        "none"
      ]
    },
    "Var":
    { 
      "snippet": "Declares a variable", 
      "summary": "Declares a variable", 
      "type": "binary infix operator",
      "syntax": "VAR name",
      "text": 
      [ 
        "none"
      ]
    },
    "Score":
    { 
      "snippet": "Used to rank result", 
      "summary": "Score is used to rank and order results from a query. The score is based on a weighted sum of attributes of the elements.", 
      "type": "binary prefix operator",
      "syntax": "linearScore[([weight1, attribute1], [weight2, attribute2]...)]",
      "text": 
      [ 
        "The Score card does not have a description yet.",
        [
          {
            "id": "a",
            "method": "",
            "type": "score",
            "weights": [
              {
                "key": "product.positive_reviews",
                "weight": "50",
                "id": "b",
                "type": "weight"
              },
              {
                "key": "product.negative_reviews",
                "weight": "-25",
                "id": "c",
                "type": "weight"
              },
              {
                "key": "product.price",
                "weight": "10",
                "id": "d",
                "type": "weight"
              }
            ]
          },
          "linearScore([\n\t[50, product.positive_reviews],\n\t[-25, product.negative_reviews],\n\t[10, product.price]]);"
        ],
      "In this example, books are scored based on their positive reviews, negative reviews and prices, ranked according to score, and the top 100 products are then selected",
        [
          {
            "cards": [
              {
                "id": "a",
                "expression": {
                  "cards": [
                    {
                      "id": "a",
                      "method": "",
                      "type": "score",
                      "weights": [
                        {
                          "key": "product.positive_reviews",
                          "weight": "50",
                          "id": "b",
                          "type": "weight"
                        },
                        {
                          "key": "product.negative_reviews",
                          "weight": "-25",
                          "id": "c",
                          "type": "weight"
                        },
                        {
                          "key": "product.price",
                          "weight": "10",
                          "id": "d",
                          "type": "weight"
                        }
                      ]
                    }
                  ],
                  "id": "g",
                  "type": "parentheses"
                },
                "field": "product.score",
                "type": "let"
              },
              {
                "id": "e",
                "type": "sort",
                "sorts": [{
                  "direction": 1,
                  "id": "f",
                  "property": "product.score",
                  "type": "sortBlock"
                }]
              }
            ],
            "fields": [
              { 
                "type": "field",
                "field": "*",
                "id": "b"
              }
            ],
            "filters": [
              { 
                "combinator": 0,
                "first": "product.type",
                "operator": 0,
                "second": "book",
                "type": "filterBlock",
                "id": "c"
              }
            ],
            "tables": [
            {
              "iterator": "product",
              "table": "'products'",
              "type": "table",
              "id": "d"
            }
            ],
            "type": "sfw",
            "id": "e"
          },
          "SELECT *\nFROM 'products' as product\nWHERE product.type = book\nLET product.score = (\n\tlinearScore([[\n\t\t[50, product.positive_reviews],\n\t\t[-25, product.negative_reviews],\n\t\t[10, product.price]\n\t])\n\tORDER BY product.score DESC;"
        ]
      ]
    },
    "Transform":
    { 
      "snippet": "none", 
      "summary": "none",
      "notation": "none",
      "syntax": "none",
      "text": 
      [ 
        "none",
        [
          {
            "bars": [],
            "domain": [0, 100],
            "id": "a",
            "input": "user.experience",
            "scorePoints": [
              {
                "id": "b",
                "score": 0.1,
                "type": "scorePoint",
                "value": 1
              },
              {
                "id": "c",
                "score": 0.38,
                "type": "scorePoint",
                "value": 25
              },
              {
                "id": "d",
                "score": 0.6,
                "type": "scorePoint",
                "value": 50
              },
              {
                "id": "e",
                "score": 0.75,
                "type": "scorePoint",
                "value": 75
              },
              {
                "id": "f",
                "score": 0.8,
                "type": "scorePoint",
                "value": 100
              }
            ],
            "type": "transform"
          },
          "linearTransform([\n\t[0.1, 1],\n\t[0.38, 25],\n\t[0.6, 100],\n\t[0.75, 75],\n\t[0.8, 100]\n]);"
        ]
      ]
    },
    "Count":
    { 
      "snippet": "Number of elements", 
      "summary": "Returns an the number of elements in the right hand expression", 
      "type": " binary prefix operator",
      "syntax": "COUNT expression",
      "text": 
      [ 
        "none",
        [
          {
            "type": "count",
            "id": "b",
            "cards": [

            ]
          },
          "count"
        ]
      ]
    },
    "Average":
    { 
      "snippet": "Returns the average", 
      "summary": "Returns the average of all elements in the right hand side.", 
      "type": "binary prefix operator",
      "syntax": "AVG expression",
      "text": 
      [ 
        "none"
      ]
    },
    "Sum":
    { 
      "snippet": "Returns the sum", 
      "summary": "Returns an the sum of all elements in the right hand side.", 
      "type": "binary prefix operator",
      "syntax": "SUM expression",
      "text": 
      [ 
        "none"
      ]
    },
    "Min":
    { 
      "snippet": "Returns minimum element", 
      "summary": "Returns an the minimum of all elements in the right hand side", 
      "type": "binary prefix operator",
      "syntax": "MIN expression",
      "text": 
      [ 
        "none"
      ]
    },
    "Max":
    { 
      "snippet": "Returns maximum element", 
      "summary": "Returns an the maximum of all elements in the right hand side", 
      "type": "binary prefix operator",
      "syntax": "MAX expression",
      "text": 
      [ 
        "none"
      ]
    },
    "Exists":
    { 
      "snippet": "Returns if exists", 
      "summary": "Tests whether the inner query returns any row.", 
      "type": "None",
      "syntax": "WHERE EXISTS (subquery)",
      "text": 
      [ 
        "none"
      ]
    },
    "( )":
    { 
      "snippet": "none", 
      "summary": "none",
      "notation": "none",
      "syntax": "none",
      "text": 
      [ 
        "none"
      ]
    },
    "Comparison":
    { 
      "snippet": "none", 
      "summary": "none",
      "notation": "none",
      "syntax": "none",
      "text": 
      [ 
        "none"
      ]
    },
    "Skip Offset":
    { 
      "snippet": "Removes first n elements", 
      "summary": "Returns a query expression representing the left-hand query expression, with the first n elements removed, where n is the result of evaluating the right-hand expression.", 
      "type": "binary infix operator",
      "syntax": "query expression SKIP expression (n)",
      "text": 
      [ 
        "none"
      ]
    }
  },
  {
    "Expression":
    {  
      "summary": "A TQL expression is any valid combination of expressions and operators that returns a single value.",
      "text": 
      [ 
        "Examples: ",
        "2",
        "'name'",
        "2+2",
        "3+2*4+func('group')"
      ]
    },
    "Statement":
    {
      "summary": "All operations performed using TQL statements",
      "text": 
      [ 
        "A Tql statement is one of: ",
        "- A code block, enclose in curly braces.",
        "- An expression that does not begin with a curly brace.",
        "- A bare semicolon, which is treated as whitespace."
      ]
    },
    "Binary Infix":
    {
      "summary": "Sits between two expressions",
      "text": 
      [ 
        "Infix notation is the notation commonly used in arithmetical and logical formulae and statements. It is characterized by the placement of operators between operands – 'infixed operators' – such as the plus sign in '2 + 2'.",
        "In infix notation, unlike in prefix or postfix notations, parentheses surrounding groups of operands and operators are necessary to indicate the intended order in which operations are to be performed. In the absence of parentheses, certain precedence rules determine the order of operations."
      ]
    },
    "Binary Prefix":
    {
      "summary": "Precedes it's target",
      "text": 
      [ 
        "You implement a prefix or postfix unary operator by writing the prefix modifier before the func keyword when declaring the operator function."
      ]
    }
  }
]