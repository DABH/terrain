[
  {
   "Select From":
    { 
      "summary": "Retrieves rows from the database if they meet the condition", 
      "notation": "none",
      "syntax": "SELECT field(s) FROM source WHERE condition(s)",
      "text": 
      [ 
        "The TQL Select statement returns a result set of records from one or more tables. A Select statement retrieves zero or more rows from one or more database tables or database views. In most applications, Select is the most commonly used data manipulation language (DML) command. As TQL is a declarative programming language, Select queries specify a result set, but do not specify how to calculate it. The database translates the query into a query plan which may vary between executions, database versions and database software. This functionality is called the query optimizer as it is responsible for finding the best possible execution plan for the query, within applicable constraints.",
         [
          {
            "cards": [],
            "fields": [
              { 
                "type": "field",
                "field": "user.name",
                "id": "b"
              }
            ],
            "filters": [
              { 
                "combinator": 0,
                "first": "user.name",
                "operator": 0,
                "second": "John",
                "type": "filterBlock",
                "id": "c"
              }
            ],
            "tables": [
            {
              "iterator": "user",
              "table": "users",
              "type": "table",
              "id": "d"
            }
            ],
            "type": "sfw",
            "id": "e",
            "helpOn": "true"
          },
          "SELECT user.name\nFROM 'users' as user\nWHERE user.name == John;"
        ],
        "This example select all the product ids purchased by user 1234:",
         [
          {
            "cards": [],
            "fields": [
              { 
                "type": "field",
                "field": "product.id",
                "id": "b"
              }
            ],
            "filters": [
              { 
                "combinator": 0,
                "first": "product.id",
                "operator": 6,
                "second": {
                  "cards": [{
                    "cards": [],
                    "fields": [
                      { 
                        "type": "field",
                        "field": "order.product",
                        "id": "bb"
                      }
                    ],
                    "filters": [
                      { 
                        "combinator": 0,
                        "first": "order.user",
                        "operator": 0,
                        "second": "1234",
                        "type": "filterBlock",
                        "id": "cc"
                      }
                    ],
                    "tables": [
                    {
                      "iterator": "order",
                      "table": "'orders'",
                      "type": "table",
                      "id": "dd"
                    }
                    ],
                    "type": "sfw",
                    "id": "ee"
                  }],
                  "id": "g",
                  "type": "parentheses"
                },
                "type": "filterBlock",
                "id": "c"
              }
            ],
            "tables": [
            {
              "iterator": "product",
              "table": "'products'",
              "type": "table",
              "id": "d"
            }
            ],
            "type": "sfw",
            "id": "e"
          },
          "SELECT product.id\nFROM 'products' as product\nWHERE product.id in (\n\tSELECT order.product\n\tFROM 'orders' as order\n\tWHERE order.user = 1234\n);"
        ]
      ]
    },
    "Take Limit":
    { 
      "snippet": "Returns n results", 
      "summary": "Returns a query expression representing the first n results from the expression on the left hand side.  The number of results n is the evaluation of the right hand side.", 
      "notation": "binary infix operator",
      "syntax": "query expression TAKE expression",
      "text": 
      [ 
        [
          {
            "type": "take",
            "value": "10",
            "id": "a",
            "helpOn": "true"
          },
          "take 10"
        ],
        "Take is a binary infix operator, meaning it sits between two expressions. Take returns a query expression that is the first n results of the query expression on its left hand side.  The number of results n to be returned is determined from the right hand side. In order to get a specific set of results, the data can be sorted based on some parameter first and then the top n results selected via Take. For example, if you wanted the 10 oldest people in a group, you would sort the people based on descending age and then use 'Take 10'.",
        "This example takes the first 10 results (the names of users) from the table 'users.'",
        [
          {
            "cards": [
              {
                "type": "take",
                "value": 10,
                "id": "a"
              }
            ],
            "fields": [
              { 
                "type": "field",
                "field": "user.name",
                "id": "b"
              }
            ],
            "filters": [
              { 
                "combinator": 0,
                "first": "user.name",
                "operator": 0,
                "second": "John",
                "type": "filterBlock",
                "id": "c"
              }
            ],
            "tables": [
            {
              "iterator": "user",
              "table": "users",
              "type": "table",
              "id": "d"
            }
            ],
            "type": "sfw",
            "id": "e"
          },
          "SELECT user.name\nFROM 'users' as user\nWHERE user.name == John\ntake 10;"
        ]
      ]
    },
    "Sort":
    { 
      "snippet": "none", 
      "summary": "Returns a query expression representing the result of filtering the left-hand expression by evaluating the right-hand expression for each element in the query  expression. Elements that cause the expression to be false are filtered out.",
      "notation": "binary infix operator",
      "syntax": "query expression sort expression",
      "text": 
      [ 
        [
          {
            "type": "sort",
            "id": "3",
            "sorts": [
              {
                "direction": 1,
                "property": "user.id",
                "id": "b"
              }
            ],
            "helpOn": "true"
          },
          "ORDER BY user.id desc"
        ],
        "A Sort clause in SQL specifies that a SQL Select statement returns a result set with the rows being sorted by the values of one or more columns. The sort criteria do not have to be included in the result set. The sort criteria can be expressions, including column names, user-defined functions, arithmetic operations, or CASE expressions. The expressions are evaluated and the results are used for the sorting, i.e., the values stored in the column or the results of the function call. ORDER BY is the only way to sort the rows in the result set. Without this clause, the relational database system may return the rows in any order. If an ordering is required, the ORDER BY must be provided in the SELECT statement sent by the application. Although some database systems allow the specification of an ORDER BY clause in subselects or view definitions, the presence there has no effect. A view is a logical relational table, and the relational model mandates that a table is a set of rows, implying no sort order whatsoever. The only exception are constructs like ORDER BY ORDER OF ... (not standardized in SQL:2003) which allow the propagation of sort criteria through nested subselects.",
        "This example sorts all the users with the name John from'users' in ascending order by their name.",
        [
          {
            "cards": [
              {
                "type": "sort",
                "id": "a",
                "sorts": [
                  {
                    "direction": 2,
                    "property": "user.name",
                    "id": "b"
                  }
                ]
              }
            ],
            "fields": [
              { 
                "type": "field",
                "field": "user.name",
                "id": "b"
              }
            ],
            "filters": [
              { 
                "combinator": 0,
                "first": "user.name",
                "operator": 0,
                "second": "John",
                "type": "filterBlock",
                "id": "c"
              }
            ],
            "tables": [
            {
              "iterator": "user",
              "table": "users",
              "type": "table",
              "id": "d"
            }
            ],
            "type": "sfw",
            "id": "e"
          },
          "SELECT user.name \n FROM users as user \n WHERE user.name == John \n\t ORDER BY user.name ASC \n ; " 
        ]
      ]
    },
    "Let":
    { 
      "snippet": "Defines variable", 
      "summary": "Returns a query expression representing the result of evaluating each the right hand statement for each element.", 
      "notation": "binary infix operator",
      "syntax": "query expression LET statement",
      "text": 
      [ 
        [
          {
            "type": "let",
            "id": "3",
            "field": "product.score",
            "expression": "product.age * product.conversionRatio",
            "helpOn": "true"
          },
          "LET product.score = \nproduct.age * product.conversionRatio "
        ],
         "This example defines a variable averageSales to be the average sales of all products where ids are less than 10 in products.",
        [
          {
            "type": "let",
            "id": "x",
            "field": "product.averageSales",
            "expression":
            {
              "id": "z",
              "type": "parentheses",
              "cards": [
                {
                  "type": "avg",
                  "id": "b",
                  "cards": [
                  {
                  "type": "sfw",
                  "id": "c",
                  "fields": [
                  { 
                    "type": "field",
                    "field": "product.sales",
                    "id": "b"
                  }
                ],
                "filters": [
                  { 
                  "combinator": 0,
                  "first": "product.id",
                  "operator": 5,
                  "second": "10",
                  "type": "filterBlock",
                  "id": "c"
                  }
                ],
                "tables": [
                {
                  "iterator": "product",
                  "table": "products",
                  "type": "table",
                  "id": "d"
                }
              ]
            }
          ]
                }
              ]
            }
          },
          "LET product.averageSales = ( \n\t AVG \n\t\tSELECT product.sales \n\t\tFROM products as product \n\t\tWHERE product.id < 10 \n\t) \n;"
        ]
      ]
    },
    "Var":
    { 
      "snippet": "Declares a variable", 
      "summary": "Declares a variable", 
      "notation": "binary infix operator",
      "syntax": "VAR name",
      "text": 
      [ 
        [
          {
            "type": "var",
            "id": "3",
            "field": "product.score",
            "expression": "product.age * product.conversionRatio",
            "helpOn": "true"
          },
          "VAR product.score = \nproduct.age * product.conversionRatio "
        ]
      ]
    },
    "Score":
    { 
      "snippet": "Used to rank result", 
      "summary": "Score is used to rank and order results from a query. The score is based on a weighted sum of attributes of the elements.", 
      "notation": "binary prefix operator",
      "syntax": "linearScore[([weight1, attribute1], [weight2, attribute2]...)]",
      "text": 
      [ 
        "The Score card does not have a description yet.",
        [
          {
            "id": "a",
            "method": "",
            "type": "score",
            "weights": [
              {
                "key": "product.positive_reviews",
                "weight": "50",
                "id": "b",
                "type": "weight"
              },
              {
                "key": "product.negative_reviews",
                "weight": "-25",
                "id": "c",
                "type": "weight"
              },
              {
                "key": "product.price",
                "weight": "10",
                "id": "d",
                "type": "weight"
              }
            ],
            "helpOn": "true"
          },
          "linearScore([\n\t[50, product.positive_reviews],\n\t[-25, product.negative_reviews],\n\t[10, product.price]]);"
        ],
      "In this example, books are scored based on their positive reviews, negative reviews and prices, ranked according to score, and the top 100 products are then selected",
        [
          {
            "cards": [
              {
                "id": "a",
                "expression": {
                  "cards": [
                    {
                      "id": "a",
                      "method": "",
                      "type": "score",
                      "weights": [
                        {
                          "key": "product.positive_reviews",
                          "weight": "50",
                          "id": "b",
                          "type": "weight"
                        },
                        {
                          "key": "product.negative_reviews",
                          "weight": "-25",
                          "id": "c",
                          "type": "weight"
                        },
                        {
                          "key": "product.price",
                          "weight": "10",
                          "id": "d",
                          "type": "weight"
                        }
                      ]
                    }
                  ],
                  "id": "g",
                  "type": "parentheses"
                },
                "field": "product.score",
                "type": "let"
              },
              {
                "id": "e",
                "type": "sort",
                "sorts": [{
                  "direction": 1,
                  "id": "f",
                  "property": "product.score",
                  "type": "sortBlock"
                }]
              }
            ],
            "fields": [
              { 
                "type": "field",
                "field": "*",
                "id": "b"
              }
            ],
            "filters": [
              { 
                "combinator": 0,
                "first": "product.type",
                "operator": 0,
                "second": "book",
                "type": "filterBlock",
                "id": "c"
              }
            ],
            "tables": [
            {
              "iterator": "product",
              "table": "'products'",
              "type": "table",
              "id": "d"
            }
            ],
            "type": "sfw",
            "id": "e"
          },
          "SELECT *\nFROM 'products' as product\nWHERE product.type = book\nLET product.score = (\n\tlinearScore([[\n\t\t[50, product.positive_reviews],\n\t\t[-25, product.negative_reviews],\n\t\t[10, product.price]\n\t])\n\tORDER BY product.score DESC;"
        ]
      ]
    },
    "Transform":
    { 
      "snippet": "none", 
      "summary": "none",
      "notation": "none",
      "syntax": "none",
      "text": 
      [ 
        "none",
        [
          {
            "bars": [],
            "domain": [0, 100],
            "id": "a",
            "input": "user.experience",
            "scorePoints": [
              {
                "id": "b",
                "score": 0.1,
                "type": "scorePoint",
                "value": 1
              },
              {
                "id": "c",
                "score": 0.38,
                "type": "scorePoint",
                "value": 25
              },
              {
                "id": "d",
                "score": 0.6,
                "type": "scorePoint",
                "value": 50
              },
              {
                "id": "e",
                "score": 0.75,
                "type": "scorePoint",
                "value": 75
              },
              {
                "id": "f",
                "score": 0.8,
                "type": "scorePoint",
                "value": 100
              }
            ],
            "type": "transform",
            "helpOn": "true"
          },
          "linearTransform([\n\t[0.1, 1],\n\t[0.38, 25],\n\t[0.6, 100],\n\t[0.75, 75],\n\t[0.8, 100]\n]);"
        ]
      ]
    },
    "Count":
    { 
      "snippet": "Number of elements", 
      "summary": "Returns an the number of elements in the right hand expression", 
      "notation": " binary prefix operator",
      "syntax": "COUNT expression",
      "text": 
      [ 
        "This example counts all the visible products.",
        [
          {
            "type": "count",
            "id": "b",
            "cards": [
            {
                "type": "sfw",
                "id": "c",
                "fields": [
                  { 
                    "type": "field",
                    "field": "product.visible",
                    "id": "b"
                  }
                ],
                "filters": [
                  { 
                  "combinator": 0,
                  "first": "product.visible",
                  "operator": 0,
                  "second": "true",
                  "type": "filterBlock",
                  "id": "c"
                  }
                ],
                "tables": [
                {
                  "iterator": "product",
                  "table": "products",
                  "type": "table",
                  "id": "d"
                }
              ]
            }
          ]
          },
          "COUNT \n\t SELECT product.visible \n\t FROM products as product \n\t WHERE product.visible = true \n;"
        ]
      ]
    },
    "Average":
    { 
      "snippet": "Returns the average", 
      "summary": "Returns the average of all elements in the right hand side.", 
      "notation": "binary prefix operator",
      "syntax": "AVG expression",
      "text": 
      [ 
        "This example defines a variable averageSales to be the average sales of all products where ids are less than 10 in products.",
        [
          {
            "type": "let",
            "id": "x",
            "field": "product.averageSales",
            "expression":
            {
              "id": "z",
              "type": "parentheses",
              "cards": [
                {
                  "type": "avg",
                  "id": "b",
                  "cards": [
                  {
                  "type": "sfw",
                  "id": "c",
                  "fields": [
                  { 
                    "type": "field",
                    "field": "product.sales",
                    "id": "b"
                  }
                ],
                "filters": [
                  { 
                  "combinator": 0,
                  "first": "product.id",
                  "operator": 5,
                  "second": "10",
                  "type": "filterBlock",
                  "id": "c"
                  }
                ],
                "tables": [
                {
                  "iterator": "product",
                  "table": "products",
                  "type": "table",
                  "id": "d"
                }
              ]
            }
          ]
                }
              ]
            }
          },
          "LET product.averageSales = ( \n\t AVG \n\t\tSELECT product.sales \n\t\tFROM products as product \n\t\tWHERE product.id < 10 \n\t) \n;"
        ]
      ]
    },
    "Sum":
    { 
      "snippet": "Returns the sum", 
      "summary": "Returns an the sum of all elements in the right hand side.", 
      "notation": "binary prefix operator",
      "syntax": "SUM expression",
      "text": 
      [ 
        "none"
      ]
    },
    "Min":
    { 
      "snippet": "Returns minimum element", 
      "summary": "Returns an the minimum of all elements in the right hand side", 
      "notation": "binary prefix operator",
      "syntax": "MIN expression",
      "text": 
      [ 
        "none"
      ]
    },
    "Max":
    { 
      "snippet": "Returns maximum element", 
      "summary": "Returns an the maximum of all elements in the right hand side", 
      "notation": "binary prefix operator",
      "syntax": "MAX expression",
      "text": 
      [ 
        "none"
      ]
    },
    "Exists":
    { 
      "snippet": "Returns if exists", 
      "summary": "Tests whether the inner query returns any row.", 
      "notation": "None",
      "syntax": "WHERE EXISTS (subquery)",
      "text": 
      [ 
        "none"
      ]
    },
    "( )":
    { 
      "snippet": "none", 
      "summary": "none",
      "notation": "none",
      "syntax": "none",
      "text": 
      [ 
        "none"
      ]
    },
    "Comparison":
    { 
      "snippet": "Returns elements that satisfy the condition", 
      "summary": "Returns a query expression representing the result of filtering the left-hand expression by evaluating the right-hand expression for each element in the query  expression. Elements that cause the expression to be false are filtered out.",
      "notation": "binary infix operator",
      "syntax": "query expression FILTER expression",
      "text": 
      [ 
        [
          {
            "type": "filter",
            "id": "a",
            "filters": [
                  { 
                    "combinator": 0,
                    "first": "product.price",
                    "operator": 4,
                    "second": "20",
                    "type": "filterBlock",
                    "id": "c"
                  }
             ],
            "helpOn": "true"
          },
          "product.price <= 20"
        ],
        "The following example returns all of the cars that are cost less than $5000 from products. ",
        [
          {
            "cards": [
              {
                "type": "filter",
                "id": "a",
                "filters": [
                  { 
                    "combinator": 0,
                    "first": "product.price",
                    "operator": 4,
                    "second": "5000",
                    "type": "filterBlock",
                    "id": "c"
                  }
                ]
              }
            ],
            "fields": [
              { 
                "type": "field",
                "field": "product.price",
                "id": "b"
              }
            ],
            "filters": [
              { 
                    "combinator": 0,
                    "first": "product.type",
                    "operator": 0,
                    "second": "car",
                    "type": "filterBlock",
                    "id": "g"
                  }
            ],
            "tables": [
            {
              "iterator": "product",
              "table": "products",
              "type": "table",
              "id": "d"
            }
            ],
            "type": "sfw",
            "id": "e"
          },
          "SELECT products.price \n FROM products as product \n WHERE product.type = car\n\t product.price <= 5000\n ; " 
        ]
      ]
    },
    "Skip Offset":
    { 
      "snippet": "Removes first n elements", 
      "summary": "Returns a query expression representing the left-hand query expression, with the first n elements removed, where n is the result of evaluating the right-hand expression.", 
      "notation": "binary infix operator",
      "syntax": "query expression SKIP expression (n)",
      "text": 
      [ 
        "none"
      ]
    }
  },
  {
    "Expression":
    {  
      "summary": "A TQL expression is any valid combination of expressions and operators that returns a single value.",
      "text": 
      [ 
        "Examples: ",
        "2",
        "'name'",
        "2+2",
        "3+2*4+func('group')"
      ]
    },
    "Statement":
    {
      "summary": "All operations performed using TQL statements",
      "text": 
      [ 
        "A Tql statement is one of: ",
        "- A code block, enclose in curly braces.",
        "- An expression that does not begin with a curly brace.",
        "- A bare semicolon, which is treated as whitespace."
      ]
    },
    "Binary Infix":
    {
      "summary": "Sits between two expressions",
      "text": 
      [ 
        "Infix notation is the notation commonly used in arithmetical and logical formulae and statements. It is characterized by the placement of operators between operands – 'infixed operators' – such as the plus sign in '2 + 2'.",
        "In infix notation, unlike in prefix or postfix notations, parentheses surrounding groups of operands and operators are necessary to indicate the intended order in which operations are to be performed. In the absence of parentheses, certain precedence rules determine the order of operations."
      ]
    },
    "Binary Prefix":
    {
      "summary": "Precedes it's target",
      "text": 
      [ 
        "You implement a prefix or postfix unary operator by writing the prefix modifier before the func keyword when declaring the operator function."
      ]
    }
  }
]